<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Hatch Log Analyzer</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh; padding: 20px;
    }
    .container {
      max-width: 1000px; margin: 0 auto;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.1);
      backdrop-filter: blur(10px);
      overflow: hidden;
    }
    .header {
      background: linear-gradient(45deg, #4f46e5, #7c3aed);
      color: white; padding: 30px; text-align: center;
    }
    .header h1 {
      font-size: 2.5rem; font-weight: 700; margin-bottom: 10px;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    .header p { font-size: 1.1rem; opacity: 0.9; }

    .controls {
      padding: 30px; background: #f8fafc; border-bottom: 1px solid #e2e8f0;
      display: flex; gap: 15px; align-items: center; flex-wrap: wrap;
    }
    .file-input-wrapper { position: relative; overflow: hidden; display: inline-block; }
    .file-input { position: absolute; left: -9999px; }

    .btn {
      padding: 12px 24px; border: none; border-radius: 10px; font-weight: 600; font-size: 14px;
      cursor: pointer; transition: all 0.3s ease; text-decoration: none; display: inline-flex; align-items: center; gap: 8px;
    }
    .btn-primary { background: linear-gradient(45deg, #4f46e5, #7c3aed); color: white; box-shadow: 0 4px 15px rgba(79,70,229,0.4); }
    .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(79,70,229,0.6); }
    .btn-secondary { background: #10b981; color: white; box-shadow: 0 4px 15px rgba(16,185,129,0.4); }
    .btn-secondary:hover { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(16,185,129,0.6); }
    .btn:disabled { background: #9ca3af; cursor: not-allowed; transform: none; box-shadow: none; }

    .file-info { flex: 1; min-width: 200px; color: #64748b; font-size: 14px; }

    .report-area { padding: 30px; min-height: 400px; }
    .welcome-message { text-align: center; color: #64748b; font-size: 18px; margin-top: 100px; }

    .error-summary {
      background: #f0f9ff; border: 1px solid #0ea5e9;
      border-radius: 12px; padding: 20px; margin-bottom: 30px;
    }
    .error-summary h2 { color: #0c4a6e; margin-bottom: 15px; font-size: 1.5rem; }

    .severity-section { margin-bottom: 30px; }
    .severity-header {
      display: flex; align-items: center; gap: 10px; margin-bottom: 15px;
      padding-bottom: 8px; border-bottom: 2px solid #e2e8f0;
    }
    .severity-high { color: #dc2626; }
    .severity-medium { color: #f59e0b; }
    .severity-low { color: #eab308; }

    .error-item {
      background: white; border: 1px solid #e2e8f0; border-radius: 10px; padding: 20px; margin-bottom: 15px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      transition: all 0.3s ease; position: relative;
    }
    .error-item:hover { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(0,0,0,0.1); }
    .error-title { font-weight: 700; color: #1e293b; margin-bottom: 8px; font-size: 1.1rem; }
    .error-explanation { color: #475569; line-height: 1.6; }

    .badge {
      position: absolute; top: 16px; right: 16px;
      background: #eef2ff; color: #3730a3;
      border: 1px solid #c7d2fe; border-radius: 9999px;
      padding: 4px 10px; font-size: 12px; font-weight: 700;
    }

    .error-meta {
      margin-top: 10px; font-size: 12px; color: #64748b;
      display: grid; grid-template-columns: 1fr; gap: 6px;
    }
    .error-meta pre {
      background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 10px; overflow: auto;
    }
    .loading { text-align: center; padding: 50px; color: #64748b; }
    .spinner {
      border: 3px solid #f3f4f6; border-top: 3px solid #4f46e5;
      border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; margin: 0 auto 20px;
    }
    @keyframes spin { 0% { transform: rotate(0deg);} 100% { transform: rotate(360deg);} }

    .error-message {
      background: #fef2f2; border: 1px solid #fecaca; color: #991b1b;
      padding: 20px; border-radius: 10px; text-align: center;
    }
    .success-message {
      background: #f0fdf4; border: 1px solid #bbf7d0; color: #166534;
      padding: 20px; border-radius: 10px; text-align: center;
    }

    @media (max-width: 768px) {
      .controls { flex-direction: column; align-items: stretch; }
      .file-info { text-align: center; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üîç Hatch Log Analyzer</h1>
      <p>Analyze device logs to identify and troubleshoot system errors</p>
    </div>

    <div class="controls">
      <div class="file-input-wrapper">
        <input type="file" id="fileInput" class="file-input" accept=".csv" />
        <label for="fileInput" class="btn btn-primary">üìÅ Select Log File (.csv)</label>
      </div>
      <button id="exportBtn" class="btn btn-secondary" disabled>üíæ Export Errors to CSV</button>
      <div class="file-info" id="fileInfo">No file selected</div>
    </div>

    <div class="report-area" id="reportArea">
      <div class="welcome-message">
        <h2>Welcome to the Hatch Log Analyzer!</h2>
        <p>Please select a CSV log file to begin analysis.</p>
      </div>
    </div>
  </div>

  <script>
    class LogAnalyzer {
      constructor() {
        this.fileInput = document.getElementById('fileInput');
        this.exportBtn = document.getElementById('exportBtn');
        this.fileInfo = document.getElementById('fileInfo');
        this.reportArea = document.getElementById('reportArea');

        this.rawFindings = [];     // all matches (one per occurrence)
        this.totalOccurrences = 0; // total count across all matches

        // Existing SD health counters (FC removed earlier)
        this.sdFieldsToWarn = ['TF','CTF','RF','WF','FE','DE'];

        this.initializeEventListeners();
        this.defineErrorRules();
      }

      initializeEventListeners() {
        this.fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
        this.exportBtn.addEventListener('click', () => this.exportToCSV());
      }

      defineErrorRules() {
        this.errorRules = [
          // Existing rules
          {
            pattern: /Backtrace:.*|Guru Meditation Error|crashdump_image_new|crashdump: Core dump partition cleared|LDR: CRASH|esp_crashdump_ets_printf_from/i,
            severity: 'High',
            title: 'Critical System Crash / Core Dump Detected',
            explanation: 'The device experienced a fatal software error, rebooted, and may have generated or cleared a crash dump file. This indicates a significant bug in the firmware and should be escalated to engineering.'
          },
          {
            pattern: /ota_watchdog_check: OTA lockup detected, forcing restart/i,
            severity: 'High',
            title: 'OTA Watchdog Failure',
            explanation: 'The device became unresponsive during a firmware update and had to force a restart. This is a critical failure that suggests the new firmware may be unstable or incompatible.'
          },
          {
            pattern: /_calculate_sd_base_size: Base SD Size: 0MB/i,
            severity: 'High',
            title: 'No Content on SD Card',
            explanation: 'The device is reporting that its SD card is empty of audio content. This will prevent the device from playing any downloaded favorites, soundscapes, or routines that require audio.'
          },
          {
            pattern: /_check_buffering: Buffering audio\.\.\./i,
            severity: 'Medium',
            title: 'Audio Buffering Detected',
            explanation: 'The audio playback was interrupted for buffering, which likely caused the sound to cut in and out. This usually points to network instability or a slow connection to the audio streaming server.'
          },
          {
            pattern: /\[E\]\[(sd|vfs_fat_sd|sdmmc_cmd)\]/i,
            severity: 'Medium',
            title: 'SD Card Communication Error',
            explanation: 'The device logged an error while trying to read from or write to the SD card. This can lead to issues with audio playback, content updates, or logging.'
          },
          {
            pattern: /LDR: Reg fail/i,
            severity: 'Medium',
            title: 'Cloud Registration Failed',
            explanation: 'The device was unable to register itself with the Hatch cloud services. This prevents the device from syncing state, receiving commands from the app, or updating content.'
          },
          {
            pattern: /LDR: CritBat/i,
            severity: 'Medium',
            title: 'Critical Battery Level',
            explanation: 'The device battery is critically low and the device will likely shut down soon. If the device is plugged in, this could indicate a charging or power hardware issue.'
          },
          {
            pattern: /icmp_ping_timeout_cb/i,
            severity: 'Low',
            title: 'Network Ping Timeout',
            explanation: 'The device sent a test signal to the local network router but did not receive a response. Occasional timeouts are normal, but frequent occurrences can point to an unstable Wi-Fi connection.'
          },

          // ===== NEW RULES (regex-only) =====
          // 2) SD Card Mount fail (High)
          {
            pattern: /vfs_fat_sdmmc:\s*sdmmc_card_init failed \(0x107\)\.|_mount_sd:\s*SD Card mount failed \(263\)|sdmmc_common:\s*sdmmc_init_ocr:\s*send_op_cond \(1\) returned 0x107|hatch_sd_remount:\s*\*\*\* We are going to attempt to remount the SD_CARD\. Attempt = \d+ \*\*\*|hal_enable_sd_card:\s*Attempted to turn SD card on, was already on|hatch_sd_remount:\s*\*\*\* We tried to remount the SD CARD but are out of retries \*\*\*/i,
            severity: 'High',
            title: 'SD Card Mount fail',
            explanation: 'Unable to mount SD Card.'
          },

          // 3) SD Card Read and write Errors (High)
          {
            pattern: /_prepare_samples:\s*audio_player_read failed \(-1\)|hatch_sd_has_file:\s*Failed to stat '.*?'|Write to SD card blocked for \d+mS!|Writing file \/mnt\/\.tmpwav failed, closing and restarting\. returnValue:\s*-1,\s*errno:\s*28|sd_fetch_wav_task:\s*SD error:\s*\d+,\s*SD status:\s*0x[0-9a-fA-F]+/i,
            severity: 'High',
            title: 'SD Card Read and write Errors',
            explanation: 'An error was detected when the SD card attempted to read or write a file.'
          },

          // 4) Full SD Card (High) ‚Äî only failure indicators
          {
            pattern: /_delete_oldest_downloaded_file:\s*Memory alloc failed!|diskio_sdmmc:\s*sdmmc_read_blocks failed \(263\)|sdmmc_cmd:\s*sdmmc_read_sectors_dma:\s*sdmmc_send_cmd returned 0x107|sd_reader_init:\s*A stat\(\) of the downloaded directory returned error 5\.|sd_reader_init:\s*A stat\(\) of the logs directory returned error 5\./i,
            severity: 'High',
            title: 'Full SD Card',
            explanation: 'Lamp unable to download tracks because the SD card is full.'
          }

          // (No generic sd_reader_log_health rule here; handled by the specialized parser below)
        ];
      }

      async handleFileSelect(event) {
        const file = event.target.files[0];
        if (!file) return;

        this.fileInfo.textContent = `Selected: ${file.name} (${(file.size / 1024).toFixed(1)} KB)`;
        this.showLoading();

        try {
          const csvData = await this.readFileAsText(file);
          this.rawFindings = this.analyzeLogData(csvData);
          this.totalOccurrences = this.rawFindings.length;
          this.updateReportDisplay();
        } catch (error) {
          this.showError('Error reading file: ' + error.message);
        }
      }

      readFileAsText(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (e) => resolve(e.target.result);
          reader.onerror = () => reject(new Error('File reading failed'));
          reader.readAsText(file);
        });
      }

      // ---- Existing SD health parsing & unified finding ----
      parseSdReaderHealth(line) {
        const payload = line.split('sd_reader_log_health:')[1]?.trim();
        if (!payload) return null;

        const norm = payload.replace(/,/g, ';');
        const parts = norm.split(';').map(s => s.trim()).filter(Boolean);

        const kv = {};
        for (const p of parts) {
          const m = p.match(/^([A-Z]+)\s*[:=]\s*([0-9.]+)$/i);
          if (m) {
            const k = m[1].toUpperCase();
            const v = Number(m[2]);
            if (!Number.isNaN(v)) kv[k] = v;
          }
        }
        return kv;
      }

      makeUnifiedSdFinding(kv, timestamp, originalLogMessage) {
        const offenders = this.sdFieldsToWarn
          .filter(k => typeof kv[k] === 'number' && kv[k] > 0)
          .map(k => `${k}=${kv[k]}`);

        if (offenders.length === 0) return null;

        return {
          timestamp,
          severity: 'High',
          title: 'SD Card Health Issues Detected',
          explanation:
            `Device reported SD health problems: ${offenders.join(', ')}. ` +
            `SD Card Health Issues Detected.`,
          originalLogMessage
        };
      }
      // ---------------------------------------------

      // ===== NEW PARSERS =====

      // 1) SD Card Data Failure (Low) ‚Äî downloader_report_stats & related lines
      parseDownloaderStats(line) {
        // Example: downloader_report_stats: Download Stats >> Max=163, Min=139, Avg=147, Count=3, failed attempts=0
        const m = line.match(/downloader_report_stats:\s*Download Stats\s*>>\s*Max=(\d+(?:\.\d+)?),\s*Min=(\d+(?:\.\d+)?),\s*Avg=(\d+(?:\.\d+)?),\s*Count=(\d+),\s*failed attempts=(\d+)/i);
        if (!m) return null;
        return {
          Max: Number(m[1]),
          Min: Number(m[2]),
          Avg: Number(m[3]),
          Count: Number(m[4]),
          Failed: Number(m[5])
        };
      }

      // 5) IoT Connectivity Health ‚Äî one card per offending metric (AD/WD/FP)
      parseIoTConnectivity(line) {
        // RC=12;RT=3600.097;AC=3586.999;AD=1;DH=0,1,0,0;WC=3600.089;WD=0;SP=60;FP=0;RMIN=-37;RMAX=-30;RA=-32.523
        if (!/[; ]AD=|[; ]WD=|[; ]FP=/.test(line)) return null;
        const parts = line.split(';').map(s => s.trim());
        const kv = {};
        for (const p of parts) {
          const m = p.match(/^([A-Z]+)\s*=\s*([-\d.]+(?:,[\d.]+)*)$/i);
          if (m) kv[m[1].toUpperCase()] = m[2];
        }
        const res = {};
        ['AD','WD','FP'].forEach(k => {
          if (k in kv) {
            const v = Number(String(kv[k]).split(',')[0]); // handle any comma group; use first number
            if (!Number.isNaN(v)) res[k] = v;
          }
        });
        return res;
      }

      // 6) Audio Error ‚Äî parse AUDIO_STAT
      parseAudioStat(line) {
        // AUDIO_STAT: V:1;F:0;FW:0;WP:3;WD:61587;WU:2;...;MU:0;...;SU:0;...
        const tagIdx = line.indexOf('AUDIO_STAT:');
        if (tagIdx === -1) return null;
        const payload = line.slice(tagIdx + 'AUDIO_STAT:'.length).trim();
        const parts = payload.split(';').map(s => s.trim()).filter(Boolean);
        const kv = {};
        for (const p of parts) {
          const m = p.match(/^([A-Z]+)\s*:\s*([-\d.]+)$/i);
          if (m) kv[m[1].toUpperCase()] = Number(m[2]);
        }
        return kv;
      }

      analyzeLogData(csvData) {
        try {
          const lines = csvData.split('\n');
          const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
          const detected = [];

          for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) continue;

            const values = this.parseCSVLine(line);
            const rowData = {};
            headers.forEach((header, index) => { rowData[header] = values[index] || ''; });

            const fullLogLine = Object.values(rowData).join(' ');
            const timestamp = rowData['log_timestamp_pt'] || 'N/A';
            const logMessage = rowData['log_message'] || fullLogLine;

            // ---- Existing: Unified SD-health handler
            if (/sd_reader_log_health:/i.test(fullLogLine)) {
              const kv = this.parseSdReaderHealth(fullLogLine);
              if (kv) {
                const f = this.makeUnifiedSdFinding(kv, timestamp, logMessage);
                if (f) detected.push(f);
              }
              // Don't let generic rules also match this line
              continue;
            }

            // ---- NEW: SD Card Data Failure
            // Stats-based (only if failed attempts > 0)
            if (/downloader_report_stats:/i.test(fullLogLine)) {
              const stats = this.parseDownloaderStats(fullLogLine);
              if (stats && stats.Failed > 0) {
                detected.push({
                  timestamp,
                  severity: 'Low',
                  title: 'SD Card Data Failure',
                  explanation:
                    `Download stats show failures. ` +
                    `Max = ${stats.Max} (max download speed), Min = ${stats.Min} (minimum), ` +
                    `Avg = ${stats.Avg} (average), Count = ${stats.Count} (files downloaded), ` +
                    `Failed attempts = ${stats.Failed} (download failures since last boot).`,
                  originalLogMessage: logMessage
                });
              }
              // Still allow generic rules below to check other patterns on this line if any
            } else if (
              /web_streamer_start_download:\s*File download queued\.\.\.|_do_download:\s*Error on file write, aborting download, errno is 28|http_client_close:\s*Closing http client connection|content_scheduler_check:\s*File .* reached maximum download attempts/i
              .test(fullLogLine)
            ) {
              detected.push({
                timestamp,
                severity: 'Low',
                title: 'SD Card Data Failure',
                explanation:
                  'A download-related error occurred. Max = maximum download speed, Min = minimum download speed, ' +
                  'Avg = average download speed, Count = number of files downloaded, Failed attempts = number of download failures since last boot.',
                originalLogMessage: logMessage
              });
              // continue through to allow other unrelated rules on the same line if needed
            }

            // ---- NEW: IoT Connectivity Health (one card per metric with value > 0)
            if (/RC=\d+;.*RMAX=.*;RA=/.test(fullLogLine)) {
              const kv = this.parseIoTConnectivity(fullLogLine);
              if (kv) {
                ['AD','WD','FP'].forEach(k => {
                  const v = kv[k];
                  if (typeof v === 'number' && v > 0) {
                    detected.push({
                      timestamp,
                      severity: 'Medium',
                      title: `IoT Connectivity Health: ${k} > 0`,
                      explanation: `Network connectivity issue detected. ${k}=${v}`,
                      originalLogMessage: logMessage
                    });
                  }
                });
              }
            }

            // ---- NEW: Audio Error (aggregate F, FW, WU, MU, SU > 0)
            if (/AUDIO_STAT:/i.test(fullLogLine)) {
              const kv = this.parseAudioStat(fullLogLine);
              if (kv) {
                const keys = ['F','FW','WU','MU','SU'];
                const offenders = keys.filter(k => typeof kv[k] === 'number' && kv[k] > 0)
                                      .map(k => `${k}=${kv[k]}`);
                if (offenders.length > 0) {
                  detected.push({
                    timestamp,
                    severity: 'High',
                    title: 'Audio Error',
                    explanation: `An error detected in audio playback. Offending counters: ${offenders.join(', ')}`,
                    originalLogMessage: logMessage
                  });
                }
              }
            }

            // ---- Existing: generic regex rules
            for (const rule of this.errorRules) {
              if (rule.pattern.test(fullLogLine)) {
                detected.push({
                  timestamp,
                  severity: rule.severity,
                  title: rule.title,
                  explanation: rule.explanation,
                  originalLogMessage: logMessage
                });
                break;
              }
            }
          }

          return detected;
        } catch (error) {
          throw new Error('Failed to parse CSV data');
        }
      }

      parseCSVLine(line) {
        const result = [];
        let current = '';
        let inQuotes = false;

        for (let i = 0; i < line.length; i++) {
          const char = line[i];
          if (char === '"') {
            if (i < line.length - 1 && line[i + 1] === '"') {
              current += '"'; i++; // escaped quote
            } else {
              inQuotes = !inQuotes;
            }
          } else if (char === ',' && !inQuotes) {
            result.push(current.trim()); current = '';
          } else {
            current += char;
          }
        }
        result.push(current.trim());
        return result;
      }

      // Group identical issues (by severity + title) for UI, with counts and a sample
      groupFindings(findings) {
        const map = new Map();
        for (const f of findings) {
          const key = `${f.severity}::${f.title}`;
          if (!map.has(key)) {
            map.set(key, {
              severity: f.severity,
              title: f.title,
              explanation: f.explanation,
              count: 1,
              sampleTimestamp: f.timestamp || 'N/A',
              sampleLog: f.originalLogMessage || ''
            });
          } else {
            map.get(key).count += 1;
          }
        }
        const grouped = {};
        for (const g of map.values()) {
          if (!grouped[g.severity]) grouped[g.severity] = [];
          grouped[g.severity].push(g);
        }
        for (const sev of Object.keys(grouped)) {
          grouped[sev].sort((a,b) => b.count - a.count);
        }
        return grouped;
      }

      updateReportDisplay() {
        if (!this.rawFindings || this.rawFindings.length === 0) {
          this.reportArea.innerHTML = `
            <div class="success-message">
              <h2>‚úÖ Analysis Complete</h2>
              <p>No errors matching the defined rules were found in this log file.</p>
            </div>`;
          this.exportBtn.disabled = true;
          return;
        }

        const groupedBySeverity = this.groupFindings(this.rawFindings);
        const severitiesPresent = Object.keys(groupedBySeverity).length;
        const severityOrder = ['High', 'Medium', 'Low'];
        const severityIcons = { High: 'üî¥', Medium: 'üü†', Low: 'üü°' };

        let html = `
          <div class="error-summary">
            <h2>‚úÖ Log Analysis Summary</h2>
            <p>Found ${this.totalOccurrences} error(s) across ${severitiesPresent} severity level(s)</p>
          </div>`;

        severityOrder.forEach(severity => {
          const items = groupedBySeverity[severity] || [];
          if (items.length > 0) {
            html += `
              <div class="severity-section">
                <div class="severity-header severity-${severity.toLowerCase()}">
                  <span style="font-size: 1.5em;">${severityIcons[severity]}</span>
                  <h3>${severity}-Severity Issues (${items.length})</h3>
                </div>`;
            items.forEach(item => {
              html += `
                <div class="error-item">
                  <div class="badge">Occurrences: ${item.count}</div>
                  <div class="error-title">${item.title}</div>
                  <div class="error-explanation">${item.explanation}</div>
                  <div class="error-meta">
                    <div><strong>Sample Timestamp:</strong> ${item.sampleTimestamp}</div>
                    <div><strong>Sample Log:</strong></div>
                    <pre>${this.escapeHtml(item.sampleLog)}</pre>
                  </div>
                </div>`;
            });
            html += `</div>`;
          }
        });

        this.reportArea.innerHTML = html;
        this.exportBtn.disabled = false;
      }

      escapeHtml(s) {
        return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
      }

      showLoading() {
        this.reportArea.innerHTML = `
          <div class="loading">
            <div class="spinner"></div>
            <p>Analyzing log file...</p>
          </div>`;
      }

      showError(message) {
        this.reportArea.innerHTML = `
          <div class="error-message">
            <h2>‚ùå Error</h2>
            <p>${message}</p>
          </div>`;
        this.exportBtn.disabled = true;
      }

      exportToCSV() {
        if (!this.rawFindings || this.rawFindings.length === 0) {
          alert('No errors to export.');
          return;
        }

        // Export *summary* view (deduped with counts)
        const grouped = this.groupFindings(this.rawFindings);
        const rows = [['Severity','Error Title','Explanation','Occurrences','Sample Timestamp','Sample Log']];

        ['High','Medium','Low'].forEach(sev => {
          (grouped[sev] || []).forEach(item => {
            rows.push([
              sev,
              item.title,
              item.explanation,
              String(item.count),
              item.sampleTimestamp || '',
              item.sampleLog || ''
            ]);
          });
        });

        const csvContent = rows.map(cols =>
          cols.map(v => `"${String(v).replace(/"/g, '""')}"`).join(',')
        ).join('\n');

        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        if (link.download !== undefined) {
          const url = URL.createObjectURL(blob);
          link.setAttribute('href', url);
          link.setAttribute('download', `hatch-log-analysis-summary-${new Date().toISOString().slice(0, 10)}.csv`);
          link.style.visibility = 'hidden';
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }
      }
    }

    // Initialize the application
    document.addEventListener('DOMContentLoaded', () => {
      new LogAnalyzer();
    });
  </script>
</body>
</html>
